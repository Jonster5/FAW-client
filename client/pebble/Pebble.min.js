var Pebble;
null == Pebble && (Pebble = class {
    static info() { return "visit www.slidemations.com for info on the Pebble API" }
    static randomInt(e = 0, t = 10) { return Math.floor(Math.random() * (t - e) + e) }
    static randomFloat(e = 0, t = 0, i) { return void 0 === i && (i = 2), parseFloat(Math.min(e + Math.random() * (t - e), t).toFixed(i)) }
});
Pebble.draggable = [], Pebble.DisplayObject = class {
    constructor() { this.x = 0, this.y = 0, this.width = 0, this.height = 0, this.rotation = 0, this.alpha = 1, this.visible = !0, this.scaleX = 1, this.scaleY = 1, this.pivotX = .5, this.pivotY = .5, this.vx = 0, this.vy = 0, this._layer = 0, this.children = [], this.parent = void 0, this.shadow = !1, this.shadowColor = "rgba(100, 100, 100, 0.5)", this.shadowOffsetX = 3, this.shadowOffsetY = 3, this.shadowBlur = 3, this.blendMode = void 0, this.frames = [], this.loop = !0, this._currentFrame = 0, this.playing = !1, this._draggable = void 0, this._circular = !1, this._interactive = !1, this.previousX = 0, this.previousY = 0 }
    get gx() { return this.parent ? this.x + this.parent.gx : this.x }
    get gy() { return this.parent ? this.y + this.parent.gy : this.y }
    get layer() { return this._layer }
    set layer(e) { this._layer = e, this.parent && this.parent.children.sort((e, t) => e.layer - t.layer) }
    addChild(e) { void 0 !== e.parent && e.parent.removeChild(e), e.parent = this, this.children.push(e) }
    removeChild(e) {
        if (e.parent !== this) throw new Error(e + "is not a child of " + this);
        this.children.splice(this.children.indexOf(e), 1)
    }
    get halfWidth() { return this.width / 2 }
    get halfHeight() { return this.height / 2 }
    get centerX() { return this.x + this.halfWidth }
    set centerX(e = 0) { this.x = e - this.halfWidth }
    get centerY() { return this.y + this.halfHeight }
    set centerY(e = 0) { this.y = e - this.halfHeight }
    get position() { return { x: this.x, y: this.y } }
    setPosition(e, t) { this.x = e, this.y = t }
    get localBounds() { return { x: 0, y: 0, width: this.width, height: this.height } }
    get globalBounds() { return { x: this.gx, y: this.gy, width: this.gx + this.width, height: this.gy + this.height } }
    get empty() { return 0 === this.children.length }
    putCenter(e, t = 0, i = 0) {
        let s = this;
        e.x = s.x + s.halfWidth - e.halfWidth + t, e.y = s.y + s.halfHeight - e.halfHeight + i
    }
    putTop(e, t = 0, i = 0) {
        let s = this;
        e.x = s.x + s.halfWidth - e.halfWidth + t, e.y = s.y - e.height + i
    }
    putRight(e, t = 0, i = 0) {
        let s = this;
        e.x = s.x + s.width + t, e.y = s.y + s.halfHeight - e.halfHeight + i
    }
    putBottom(e, t = 0, i = 0) {
        let s = this;
        e.x = s.x + s.halfWidth - e.halfWidth + t, e.y = s.y + s.height + i
    }
    putLeft(e, t = 0, i = 0) {
        let s = this;
        e.x = s.x - e.width + t, e.y = s.y + s.halfHeight - e.halfHeight + i
    }
    swapChildren(e, t) {
        let i = this.children.indexOf(e),
            s = this.children.indexOf(t);
        if (-1 === i || -1 === s) throw new Error(`Both objects must be a child of the caller ${this}`);
        e.childIndex = s, t.childIndex = i, this.children[i] = t, this.children[s] = e
    }
    add(...e) { e.forEach(e => this.addChild(e)) }
    remove(...e) { e.forEach(e => this.removeChild(e)) }
    addArray(e = []) { e.forEach(e => this.addChild(e)) }
    removeArray(e = []) { e.forEach(e => this.removeChild(e)) }
    get currentFrame() { return this._currentFrame }
    get circular() { return this._circular }
    set circular(e) {!0 === e && !1 === this._circular && (Object.defineProperties(this, { diameter: {get() { return this.width }, set(e) { this.width = e, this.height = e }, enumerable: !0, configurable: !0 }, radius: {get() { return this.halfWidth }, set(e) { this.width = 2 * e, this.height = 2 * e }, enumerable: !0, configurable: !0 } }), this._circular = !0), !1 === e && !0 === this._circular && (delete this.diameter, delete this.radius, this._circular = !1) }
    get draggable() { return this._draggable }
    set draggable(e) {!0 === e && (draggableSprites.push(this), this._draggable = !0), !1 === e && draggableSprites.splice(draggableSprites.indexOf(this), 1) }
    get interactive() { return this._interactive }
    set interactive(e) {!0 === e && (makeInteractive(this), Pebble.buttons.push(this), this._interactive = !0), !1 === e && (buttons.splice(buttons.indexOf(this), 1), this._interactive = !1) }
}, Pebble.Canvas = class {
    constructor(e = document.body, t = 400, i = 400, s = "1px dashed black", a = "white") {
        let r = document.createElement("canvas");
        r.setAttribute("width", t), r.setAttribute("height", i), e.appendChild(r);
        let n = window.devicePixelRatio || 1,
            o = r.getBoundingClientRect();
        return r.width = o.width * n, r.height = o.height * n, r.ctx = r.getContext("2d"), r.ctx.scale(n, n), r.setAttribute("style", `width: ${t}px; height: ${i}px; border: ${s}; background: ${a};`), {
            width: t,
            height: i,
            scale: 0,
            ctx: r.ctx,
            domElement: r,
            parent: e,
            aspect: { x: t, y: i },
            scaleToWindow(e = "grey", t) {
                let i, s, a;
                if (i = window.innerWidth / this.width, s = window.innerHeight / this.height, a = Math.min(i, s), this.domElement.style.transformOrigin = "0 0", this.domElement.style.transform = "scale(" + a + ")", parseFloat(this.domElement.style.width) > parseFloat(this.domElement.style.height)) {
                    let e = (window.innerHeight - parseFloat(this.domElement.style.height) * i) / 2;
                    this.domElement.style.marginTop = e + "px", this.domElement.style.marginBottom = e + "px"
                } else {
                    let e = (window.innerWidth - parseFloat(this.domElement.style.width) * s) / 2;
                    this.domElement.style.marginLeft = e + "px", this.domElement.style.marginRight = e + "px"
                }
                this.domElement.style.paddingLeft = 0, this.domElement.style.paddingRight = 0, this.domElement.style.display = "block", this.parent.style.backgroundColor = e, t.scale = a, this.scale = a
            },
            cancelReaction() { window.removeEventListener("resize") },
            exportAsPNG(e = "") {
                try {
                    let t = this.domElement,
                        i = "image/png",
                        s = t.toDataURL(i),
                        a = document.createElement("a");
                    return a.download = e, a.href = s, a.dataset.downloadurl = [i, a.download, a.href].join(":"), document.body.appendChild(a), a.click(), document.body.removeChild(a), !0
                } catch (e) { return !1 }
            },
            exportAsJPG(e = "") {
                try {
                    let t = this.domElement,
                        i = "image/jpeg",
                        s = t.toDataURL(i),
                        a = document.createElement("a");
                    return a.download = e, a.href = s, a.dataset.downloadurl = [i, a.download, a.href].join(":"), document.body.appendChild(a), a.click(), document.body.removeChild(a), !0
                } catch (e) { return !1 }
            }
        }
    }
}, Pebble.Stage = class extends Pebble.DisplayObject { constructor(e = 0, t = 0) { super(), this.width = e, this.height = t } }, Pebble.render = function(e, t, i = !1, s) {
    let a = e.ctx;

    function r(t) { t.visible && t.gx < e.width + t.width && t.gx + t.width >= -t.width && t.gy < e.height + t.height && t.gy + t.height >= -t.height && (a.save(), a.translate(t.x + t.width * t.pivotX, t.y + t.height * t.pivotY), a.rotate(t.rotation), a.globalAlpha = t.alpha * t.parent.alpha, a.scale(t.scaleX, t.scaleY), t.shadow && (cx.shadowColor = t.shadowColor, a.shadowOffsetX = t.shadowOffsetX, a.shadowOffsetY = t.shadowOffsetY, a.shadowBlur = t.shadowBlur), t.blendMode && (a.globalCompositeOperation = t.blendMode), t.render && t.render(a), t.children && t.children.length > 0 && (a.translate(-t.width * t.pivotX, -t.height * t.pivotY), t.children.forEach(e => { r(e) })), a.restore()) }
    a.clearRect(0, 0, e.width, e.height), t.children.forEach(t => { i ? function(t) { t.visible && t.gx < e.width + t.width && t.gx + t.width > -t.width && t.gy < e.height + t.height && t.gy + t.height > -t.height && (a.save(), void 0 !== t.previousX ? t.renderX = (t.x - t.previousX) * s + t.previousX : t.renderX = t.x, void 0 !== t.previousY ? t.renderY = (t.y - t.previousY) * s + t.previousY : t.renderY = t.y, a.translate(t.renderX + t.width * t.pivotX, t.renderY + t.height * t.pivotY), a.rotate(t.rotation), a.globalAlpha = t.alpha * t.parent.alpha, a.scale(t.scaleX, t.scaleY), t.shadow && (a.shadowColor = t.shadowColor, a.shadowOffsetX = t.shadowOffsetX, a.shadowOffsetY = t.shadowOffsetY, a.shadowBlur = t.shadowBlur), t.blendMode && (a.globalCompositeOperation = t.blendMode), t.render && t.render(a), t.children && t.children.length > 0 && (a.translate(-t.width * t.pivotX, -t.height * t.pivotY), t.children.forEach(e => { r(e) })), a.restore()) }(t) : r(t) })
}, Pebble.interpolationData = { _fps: 60, previous: 0, lag: 0, get FPS() { return this._fps }, set FPS(e) { this._fps = e } }, Pebble.frameData = { times: [], FPS: 0 }, Pebble.refreshLoop = function() {
    window.requestAnimationFrame(() => {
        const e = performance.now();
        for (; Pebble.frameData.times.length > 0 && Pebble.frameData.times[0] <= e - 1e3;) Pebble.frameData.times.shift();
        Pebble.frameData.times.push(e), Pebble.frameData.FPS = Pebble.frameData.times.length, this.refreshLoop()
    })
}, Pebble.getLagOffset = function(e, t) {
    let i = 1e3 / this.interpolationData._fps;
    e || (e = 0);
    let s = e - this.interpolationData.previous;

    function a(e) {
        e.children.forEach(e => {
            ! function e(t) {
                t.previousX = t.x;
                t.previousY = t.y;
                t.children && t.children.length > 0 && t.children.forEach(t => { e(t) })
            }(e)
        })
    }
    for (s > 1e3 && (s = i), this.interpolationData.lag += s; this.interpolationData.lag >= i;) a(stage), t(), this.interpolationData.lag -= i;
    return this.interpolationData.previous = e, this.interpolationData.lag / i
}, Pebble.buttons = [], Pebble.Rectangle = function(e = 32, t = 32, i = "gray", s = "none", a = 0, r = 0, n = 0) { let o = new RectangleCanvasObject(e, t, i, s, a, r, n); return stage && stage.addChild(o), o }, Pebble.Circle = function(e = 32, t = "gray", i = "none", s = 0, a = 0, r = 0) { let n = new CircleCanvasObject(e, t, i, s, a, r); return stage && stage.addChild(n), n }, Pebble.Line = function(e = 0, t = 0, i = 0, s = 0, a = "none", r = 1) { let n = new LineCanvasObject(a, r, e, t, i, s); return stage && stage.addChild(n), n }, Pebble.Text = function(e = "", t = "12px sans-serif", i = "black", s = 0, a = 0) { let r = new TextCanvasObject(e, t, i, s, a); return stage && stage.addChild(r), r }, Pebble.Group = function(...e) { let t = new ObjectGrouper(e); return stage && stage.addChild(t), t }, Pebble.Sprite = function(e, t = 0, i = 0) { let s = new SpriteCanvasObject(e, t, i); return s.frames.length > 0 && Pebble.addStatePlayer(s), stage && stage.addChild(s), s }, Pebble.Button = function(e, t, i) { let s = new ButtonObject(e, t, i); return stage && stage.addChild(s), s }, Pebble.Marker = function(e = 0, t = 0) { let i = new MarkerCanvasObject(e, t); return stage && stage.addChild(i), i };
class RectangleCanvasObject extends Pebble.DisplayObject {
    constructor(e = 32, t = 32, i = "gray", s = "none", a = 0, r = 0, n = 0) { super(), Object.assign(this, { width: e, height: t, fillStyle: i, strokeStyle: s, lineWidth: a, x: r, y: n }), this.mask = !1 }
    render(e) { e.strokeStyle = this.strokeStyle, e.lineWidth = this.lineWidth, e.fillStyle = this.fillStyle, e.beginPath(), e.rect(-this.width * this.pivotX, -this.height * this.pivotY, this.width, this.height), "none" !== this.strokeStyle && e.stroke(), "none" !== this.fillStyle && e.fill(), this.mask && !0 === this.mask && e.clip() }
}
class MarkerCanvasObject extends Pebble.DisplayObject { constructor(e = 0, t = 0) { super(), Object.assign(this, { x: e, y: t }) } }
class CircleCanvasObject extends Pebble.DisplayObject {
    constructor(e = 32, t = "gray", i = "none", s = 0, a = 0, r = 0) { super(), this.circular = !0, Object.assign(this, { diameter: e, fillStyle: t, strokeStyle: i, lineWidth: s, x: a, y: r }), this.mask = !1 }
    render(e) { e.strokeStyle = this.strokeStyle, e.lineWidth = this.lineWidth, e.fillStyle = this.fillStyle, e.beginPath(), e.arc(this.radius + -this.diameter * this.pivotX, this.radius + -this.diameter * this.pivotY, this.radius, 0, 2 * Math.PI, !1), "none" !== this.strokeStyle && e.stroke(), "none" !== this.fillStyle && e.fill(), this.mask && !0 === this.mask && e.clip() }
}
class LineCanvasObject extends Pebble.DisplayObject {
    constructor(e = "none", t = 0, i = 0, s = 0, a = 0, r = 0) { super(), Object.assign(this, { strokeStyle: e, lineWidth: t, ax: i, ay: s, bx: a, by: r }), this.lineJoin = "rounded" }
    render(e) { e.strokeStyle = this.strokeStyle, e.lineWidth = this.lineWidth, e.lineJoin = this.lineJoin, e.beginPath(), e.moveTo(this.ax, this.ay), e.lineTo(this.bx, this.by), "none" !== this.strokeStyle && e.stroke() }
}
class TextCanvasObject extends Pebble.DisplayObject {
    constructor(e = "", t = "12px sans-serif", i = "black", s, a) {
        if (super(), Object.assign(this, { content: e, font: t, fillStyle: i, x: s, y: a }), this.textBaseline = "top", this.strokeText = "none", 0 === this.width) {
            let e = new Pebble.Canvas;
            e.domElement.style.display = "none", e.domElement.style.position = "absolute";
            let t = e.ctx;
            t.font = this.font, t.strokeStyle = this.strokeStyle, t.lineWidth = this.lineWidth, t.fillStyle = this.fillStyle, this.width = t.measureText(this.content).width, document.body.removeChild(e.domElement)
        }
        if (0 === this.height) {
            let e = new Pebble.Canvas;
            e.domElement.style.display = "none", e.domElement.style.position = "absolute";
            let t = e.ctx;
            t.font = this.font, t.strokeStyle = this.strokeStyle, t.lineWidth = this.lineWidth, t.fillStyle = this.fillStyle, this.height = t.measureText("M").width, document.body.removeChild(e.domElement)
        }
    }
    render(e) { e.font = this.font, e.strokeStyle = this.strokeStyle, e.lineWidth = this.lineWidth, e.fillStyle = this.fillStyle, this.width = e.measureText(this.content).width, this.height = e.measureText("M").width, e.translate(-this.width * this.pivotX, -this.height * this.pivotY), e.textBaseline = this.textBaseline, e.fillText(this.content, 0, 0), "none" !== this.strokeText && e.strokeText() }
}
class ObjectGrouper extends Pebble.DisplayObject {
    constructor(...e) { super(), e.forEach(e => this.addChild(e)) }
    addChild(e) { e.parent && e.parent.removeChild(e), e.parent = this, this.children.push(e), this.calculateSize() }
    removeChild(e) {
        if (e.parent !== this) throw new Error(`${e} is not a child of ${this}`);
        this.children.splice(this.children.indexOf(e), 1), this.calculateSize()
    }
    add(...e) { e.forEach(e => { this.addChild(e) }) }
    remove(...e) { e.forEach(e => { this.removeChild(e) }) }
    addArray(e) { e.forEach(e => { this.addChild(e) }) }
    removeArray(...e) { e.forEach(e => { this.removeChild(e) }) }
    calculateSize() { this.children.length > 0 && (this._newWidth = 0, this._newHeight = 0, this.children.forEach(e => { e.x + e.width > this._newWidth && (this._newWidth = e.x + e.width), e.y + e.height > this._newHeight && (this._newHeight = e.y + e.height) }), this.width = this._newWidth, this.height = this._newHeight) }
}
class SpriteCanvasObject extends Pebble.DisplayObject {
    constructor(e, t = 0, i = 0) {
        if (super(), Object.assign(this, { x: t, y: i }), e instanceof Image) this.createFromImage(e);
        else if (e.frame) this.createFromAtlas(e);
        else if (e.image && !e.data) this.createFromTileset(e);
        else if (e.image && e.data) this.createFromTilesetFrames(e);
        else {
            if (!(e instanceof Array)) throw new Error(`The image source ${e} is not recognized`);
            if (e[0] && e[0].source) this.createFromAtlasFrames(e);
            else {
                if (!(e[0] instanceof Image)) throw new Error(`The image sources in ${e} are not recognized`);
                this.createFromImages(e)
            }
        }
    }
    createFromImage(e) {
        if (!(e instanceof Image)) throw new Error(`${e} is not an image object`);
        this.source = e, this.sourceX = 0, this.sourceY = 0, this.width = e.width, this.height = e.height, this.sourceWidth = e.width, this.sourceHeight = e.height
    }
    createFromAtlas(e) { this.tilesetFrame = e, this.source = this.tilesetFrame.source, this.sourceX = this.tilesetFrame.frame.x, this.sourceY = this.tilesetFrame.frame.y, this.width = this.tilesetFrame.frame.w, this.height = this.tilesetFrame.frame.h, this.sourceWidth = this.tilesetFrame.frame.w, this.sourceHeight = this.tilesetFrame.frame.h }
    createFromTileset(e) {
        if (!(e.image instanceof Image)) throw new Error(`${e.image} is not an image object`);
        this.source = e.image, this.sourceX = e.x, this.sourceY = e.y, this.width = e.width, this.height = e.height, this.sourceWidth = e.width, this.sourceHeight = e.height
    }
    createFromTilesetFrames(e) {
        if (!(e.image instanceof Image)) throw new Error(`${e.image} is not an image object`);
        this.source = e.image, this.frames = e.data, this.sourceX = this.frames[0][0], this.sourceY = this.frames[0][1], this.width = e.width, this.height = e.height, this.sourceWidth = e.width, this.sourceHeight = e.height
    }
    createFromAtlasFrames(e) { this.frames = e, this.source = e[0].source, this.sourceX = e[0].frame.x, this.sourceY = e[0].frame.y, this.width = e[0].frame.w, this.height = e[0].frame.h, this.sourceWidth = e[0].frame.w, this.sourceHeight = e[0].frame.h }
    createFromImages(e) { this.frames = e, this.source = e[0], this.sourceX = 0, this.sourceY = 0, this.width = e[0].width, this.height = e[0].width, this.sourceWidth = e[0].width, this.sourceHeight = e[0].height }
    gotoAndStop(e) {
        if (!(this.frames.length > 0 && e < this.frames.length)) throw new Error(`Frame number ${e} does not exist`);
        this.frames[0] instanceof Array ? (this.sourceX = this.frames[e][0], this.sourceY = this.frames[e][1]) : this.frames[e].frame ? (this.sourceX = this.frames[e].frame.x, this.sourceY = this.frames[e].frame.y, this.sourceWidth = this.frames[e].frame.w, this.sourceHeight = this.frames[e].frame.h, this.width = this.frames[e].frame.w, this.height = this.frames[e].frame.h) : (this.source = this.frames[e], this.sourceX = 0, this.sourceY = 0, this.width = this.source.width, this.height = this.source.height, this.sourceWidth = this.source.width, this.sourceHeight = this.source.height), this._currentFrame = e
    }
    render(e) { e.drawImage(this.source, this.sourceX, this.sourceY, this.sourceWidth, this.sourceHeight, -this.width * this.pivotX, -this.height * this.pivotY, this.width, this.height) }
}
class ButtonObject extends SpriteCanvasObject { constructor(e, t = 0, i = 0) { super(e, t, i), this.interactive = !0 } }

function makeInteractive(e) {
    e.press = e.press || void 0, e.release = e.release || void 0, e.over = e.over || void 0, e.out = e.out || void 0, e.tap = e.tap || void 0, e.state = "up", e.action = "", e.pressed = !1, e.hoverOver = !1, e.update = ((t, i) => {
        let s = t.hitTestSprite(e);
        t.isUp && (e.state = "up", e instanceof ButtonObject && e.gotoAndStop(0)), s && (e.state = "over", e.frames && 3 === e.frames.length && e instanceof ButtonObject && e.gotoAndStop(1), t.isDown && (e.state = "down", e instanceof ButtonObject && (3 === e.frames.length ? e.gotoAndStop(2) : e.gotoAndStop(1)))), "down" === e.state && (e.pressed || (e.press && e.press(), e.pressed = !0, e.action = "pressed")), "over" === e.state && (e.pressed && (e.release && e.release(), e.pressed = !1, e.action = "released", t.tapped && e.tap && e.tap()), e.hoverOver || (e.over && e.over(), e.hoverOver = !0)), "up" === e.state && (e.pressed && (e.release && e.release(), e.pressed = !1, e.action = "released"), e.hoverOver && (e.out && e.out(), e.hoverOver = !1))
    })
}(Pebble.addStatePlayer = function(e) {
    let t = 0,
        i = 0,
        s = 0,
        a = 0,
        r = void 0;

    function n(n) {
        o(), s = n[0], a = n[1], i = a - s, 0 === s && (i += 1, t += 1), 1 === i && (i = 2, t += 1), e.fps || (e.fps = 12);
        let h = 1e3 / e.fps;
        e.gotoAndStop(s), e.playing || (r = setInterval(function() { t < i ? (e.gotoAndStop(e.currentFrame + 1), t += 1) : e.loop && (e.gotoAndStop(s), t = 1) }.bind(this), h), e.playing = !0)
    }

    function o() { void 0 !== r && !0 === e.playing && (e.playing = !1, t = 0, s = 0, a = 0, i = 0, clearInterval(r)) }
    e.show = function(t) { o(), e.gotoAndStop(t) }, e.play = function() { e.playing || n([0, e.frames.length - 1]) }, e.stop = function() { e.playing && (o(), e.gotoAndStop(e.currentFrame)) }, e.playSequence = n
}, Pebble.VoxelGrid = class { constructor() {} }, null == Pebble) && (Pebble = class {
    static randomInt(e = 0, t = 10) { return Math.floor(Math.random() * (t - e) + e) }
    static randomFloat(e = 0, t = 0, i) { return void 0 === i && (i = 2), parseFloat(Math.min(e + Math.random() * (t - e), t).toFixed(i)) }
});
Pebble.AssetLoader = class {
    constructor() { this.toLoad = 0, this.loaded = 0, this.imageExtensions = ["png", "jpg", "gif"], this.fontExtensions = ["ttf", "otf", "ttc", "woff"], this.jsonExtensions = ["json"], this.audioExtensions = ["mp3", "ogg", "wav", "webm"], this.scriptExtensions = ["pbl", "js"] }
    load(e = [], t = !1) {
        return new Promise(i => {
            let s = () => { this.loaded += 1, t && console.log(this.loaded), this.toLoad === this.loaded && (this.toLoad = 0, this.loaded = 0, t && console.log("Assets finished loading"), i()) };
            t && console.log("Loading assets..."), this.toLoad = e.length, e.forEach(e => { let t = e.split(".").pop(); - 1 !== this.imageExtensions.indexOf(t) ? this.loadImage(e, s) : -1 !== this.fontExtensions.indexOf(t) ? this.loadFont(e, s) : -1 !== this.jsonExtensions.indexOf(t) ? this.loadJson(e, s) : -1 !== this.audioExtensions.indexOf(t) ? this.loadSound(e, s) : -1 !== this.scriptExtensions.indexOf(t) ? this.loadScript(e, s) : console.error("File type not recognized: " + e) })
        })
    }
    loadImage(e, t) {
        let i = new Image;
        i.addEventListener("load", t, !1), this[e] = i, i.src = e
    }
    loadScript(e, t) {
        let i = new XMLHttpRequest;
        i.open("GET", e, !0), i.responseType = "text", i.onload = (s => {
            if (200 === i.status) {
                let s = {
                    source: i.responseText,
                    execute() {
                        return new Promise(e => {
                            let t = document.createElement("script");
                            t.innerHTML = this.source, document.body.appendChild(t), e()
                        })
                    }
                };
                this[e] = s, t()
            }
        }), i.send()
    }
    loadFont(e, t) {
        let i = e.split("/").pop().split(".")[0],
            s = document.createElement("style"),
            a = "@font-face {font-family: '" + i + "'; src: url('" + e + "');}";
        s.appendChild(document.createTextNode(a)), document.head.appendChild(s), t()
    }
    loadJson(e, t) {
        let i = new XMLHttpRequest;
        i.open("GET", e, !0), i.responseType = "text", i.onload = (s => {
            if (200 === i.status) {
                let s = JSON.parse(i.responseText);
                s.name = e, this[s.name] = s, s.frames ? this.createTilesetFrames(s, e, t) : t()
            }
        }), i.send()
    }
    createTilesetFrames(e, t, i) {
        let s = t.replace(/[^\/]*$/, "") + e.meta.image,
            a = new Image;
        a.addEventListener("load", () => { this[s] = a, Object.keys(e.frames).forEach(t => { this[t] = e.frames[t], this[t].source = a }), i() }, !1), a.src = s
    }
    loadSound(e, t) {
        let i = Pebble.Sound(e, t);
        i.name = e, this[i.name] = i
    }
}, Pebble.actx = new AudioContext;
class Sound {
    constructor(e, t) { this.source = e, this.loadHandler = t, this.actx = Pebble.actx, this.volumeNode = this.actx.createGain(), this.panNode = this.actx.createStereoPanner(), this.convolverNode = this.actx.createConvolver(), this.delayNode = this.actx.createDelay(), this.feedbackNode = this.actx.createGain(), this.filterNode = this.actx.createBiquadFilter(), this.soundNode = null, this.buffer = null, this.loop = !1, this.playing = !1, this.panValue = 0, this.volumeValue = 1, this.startTime = 0, this.startOffset = 0, this.playbackRate = 1, this.randomPitch = !0, this.reverb = !1, this.reverbImpulse = null, this.echo = !1, this.delayValue = .3, this.feebackValue = .3, this.filterValue = 0, this.load() }
    load() {
        let e = new XMLHttpRequest;
        e.open("GET", this.source, !0), e.responseType = "arraybuffer", e.addEventListener("load", () => { this.actx.decodeAudioData(e.response, e => { this.buffer = e, this.hasLoaded = !0, this.loadHandler && this.loadHandler() }, e => { throw new Error("Audio could not be decoded: " + e) }) }), e.send()
    }
    play() { this.startTime = this.actx.currentTime, this.soundNode = this.actx.createBufferSource(), this.soundNode.buffer = this.buffer, this.soundNode.connect(this.volumeNode), !1 === this.reverb ? this.volumeNode.connect(this.panNode) : (this.volumeNode.connect(this.convolverNode), this.convolverNode.connect(this.panNode), this.convolverNode.buffer = this.reverbImpulse), this.panNode.connect(this.actx.destination), this.echo && (this.feedbackNode.gain.value = this.feebackValue, this.delayNode.delayTime.value = this.delayValue, this.filterNode.frequency.value = this.filterValue, this.delayNode.connect(this.feedbackNode), this.filterValue > 0 ? (this.feedbackNode.connect(this.filterNode), this.filterNode.connect(this.delayNode)) : this.feedbackNode.connect(this.delayNode), this.volumeNode.connect(this.delayNode), this.delayNode.connect(this.panNode)), this.soundNode.loop = this.loop, this.soundNode.playbackRate.value = this.playbackRate, this.soundNode.start(this.startTime, this.startOffset % this.buffer.duration), this.playing = !0 }
    setReverb(e = 2, t = 2, i = !1) { this.reverbImpulse = impulseResponse(e, t, i), this.reverb = !0 }
    setEcho(e = .3, t = .3, i = 0) { this.delayValue = e, this.feebackValue = t, this.filterValue = i, this.echo = !0 }
    pause() { if (this.playing) return this.soundNode.stop(this.actx.currentTime), this.startOffset += this.actx.currentTime - this.startTime, this.playing = !1, this.startOffset }
    restart() { this.playing && this.soundNode.stop(this.actx.currentTime), this.startOffset = 0, this.startPoint = 0, this.endPoint = this.buffer.duration, this.play() }
    playFrom(e) { this.playing && this.soundNode.stop(this.actx.currentTime), this.startOffset = e, this.play() }
    playSection(e, t) {
        this.playing && this.soundNode.stop(this.actx.currentTime), 0 === this.startOffset && (this.startOffset = e), this.startTime = this.actx.currentTime, this.soundNode = this.actx.createBufferSource(), this.soundNode.buffer = this.buffer, this.soundNode.connect(this.panNode), this.panNode.connect(this.volumeNode), this.volumeNode.connect(this.actx.destination), this.soundNode.loop = this.loop, this.soundNode.loopStart = e, this.soundNode.loopEnd = t;
        let i = t - e;
        this.soundNode.start(this.startTime, this.startOffset % this.buffer.duration, i), this.playing = !0
    }
    get volume() { return this.volumeValue }
    set volume(e) { this.volumeNode.gain.value = e, this.volumeValue = e }
    get pan() { return this.panNode.pan.value }
    set pan(e) { this.panNode.pan.value = e }
}

function impulseResponse(e = 2, t = 2, i = !1) {
    let s = Pebble.actx.sampleRate * e,
        a = actx.createBuffer(2, s, Pebble.actx.sampleRate),
        r = a.getChannelData(0),
        n = a.getChannelData(1);
    for (let e = 0; e < s; e++) {
        let a;
        a = i ? s - e : e, r[e] = (2 * Math.random() - 1) * Math.pow(1 - a / s, t), n[e] = (2 * Math.random() - 1) * Math.pow(1 - a / s, t)
    }
    return a
}
if (Pebble.Sound = function(e, t) { return new Sound(e, t) }, Pebble.soundEffect = function(e, t = 0, i = 1, s = "sine", a = 1, r = 0, n = 0, o = 0, h = !1, l = 0, d = 0, c, u) {
        let f, g = Pebble.actx.createOscillator(),
            p = Pebble.actx.createGain(),
            b = Pebble.actx.createStereoPanner();
        g.connect(p), p.connect(b), b.connect(Pebble.actx.destination), p.gain.value = a, b.pan.value = r, g.type = s;

        function m(e) {
            let t = actx.createConvolver();
            t.buffer = impulseResponse(u[0], u[1], u[2]), e.connect(t), t.connect(b)
        }

        function y(e) {
            let t = Pebble.actx.createGain(),
                i = Pebble.actx.createDelay(),
                s = Pebble.actx.createBiquadFilter();
            i.delayTime.value = c[0], t.gain.value = c[1], c[2] && (s.frequency.value = c[2]), i.connect(t), c[2] ? (t.connect(s), s.connect(i)) : t.connect(i), e.connect(i), i.connect(b)
        }

        function x(e) { e.gain.value = 0, e.gain.linearRampToValueAtTime(0, Pebble.actx.currentTime + n), e.gain.linearRampToValueAtTime(a, Pebble.actx.currentTime + n + t) }

        function w(e) { e.gain.linearRampToValueAtTime(a, Pebble.actx.currentTime + t + n), e.gain.linearRampToValueAtTime(0, Pebble.actx.currentTime + n + t + i) }

        function v(e) {
            let s = e.frequency.value;
            h ? (e.frequency.linearRampToValueAtTime(s, Pebble.actx.currentTime + n), e.frequency.linearRampToValueAtTime(s + o, Pebble.actx.currentTime + n + t + i)) : (e.frequency.linearRampToValueAtTime(s, Pebble.actx.currentTime + n), e.frequency.linearRampToValueAtTime(s - o, Pebble.actx.currentTime + n + t + i))
        }

        function P(e) { e.start(Pebble.actx.currentTime + n) }
        f = l > 0 ? ((e, t) => Math.floor(Math.random() * (t - e + 1)) + e)(e - l / 2, e + l / 2) : e, g.frequency.value = f, t > 0 && x(p), i > 0 && w(p), o > 0 && v(g), c && y(p), u && m(p), d > 0 && function() {
            let e = Pebble.actx.createOscillator(),
                s = Pebble.actx.createOscillator(),
                r = Pebble.actx.createGain(),
                n = Pebble.actx.createGain();
            r.gain.value = a, n.gain.value = a, e.connect(r), r.connect(Pebble.actx.destination), s.connect(n), n.connect(Pebble.actx.destination), e.type = "sawtooth", s.type = "sawtooth", e.frequency.value = f + d, s.frequency.value = f - d, t > 0 && (x(r), x(n));
            i > 0 && (w(r), w(n));
            o > 0 && (v(e), v(s));
            c && (y(r), y(n));
            u && (m(r), m(n));
            P(e), P(s)
        }(), P(g)
    }, Pebble.sounds = { laserShot: (e = 1) => Pebble.soundEffect(1046.5, 0, .3, "sawtooth", e, 0, 0, 1200, !1, 0, 25, [.2, .2, 2e3], void 0), jump: (e = 3) => Pebble.soundEffect(423.25, .05, .2, "sine", e, 0, 0, 600, !0, 100, 0, void 0, void 0), explosion: (e = 1) => Pebble.soundEffect(16, 0, 1, "sawtooth", e, 0, 0, 0, !1, 0, 50, void 0, void 0), bonus: (e = 1) => { Pebble.soundEffect(587.33, 0, .2, "square", e, 0, 0), Pebble.soundEffect(880, 0, .2, "square", e, 0, .1), Pebble.soundEffect(1174.66, 0, .3, "square", e, 0, .2) } }, void 0 === Pebble.DisplayObject || null === Pebble.DisplayObject) throw new Error("You must have Pebble-2d installed before you can use Pebble-collisions");

function hitTestPoint(e, t) { let i, s, a, r, n, o, h, l, d; return "rectangle" === (i = t.radius ? "circle" : "rectangle") && (s = t.x, a = t.x + t.width, r = t.y, n = t.y + t.height, d = e.x > s && e.x < a && e.y > r && e.y < n), "circle" === i && (o = e.x - t.centerX, h = e.y - t.centerY, d = (l = Math.sqrt(o * o + h * h)) < t.radius), d }

function hitTestCircle(e, t, i = !1) { let s, a, r, n, o; return i ? (s = t.gx + t.radius - (e.gx + e.radius), a = t.gy + t.radius - (e.gy + e.radius)) : (s = t.centerX - e.centerX, a = t.centerY - e.centerY), o = (r = Math.sqrt(s * s + a * a)) < (n = e.radius + t.radius) }

function circleCollision(e, t, i = !1, s = !1) {
    let a, r, n, o, h, l, d, c = {},
        u = !1;
    if (s ? (o = t.gx + t.radius - (e.gx + e.radius), h = t.gy + t.radius - (e.gy + e.radius)) : (o = t.centerX - e.centerX, h = t.centerY - e.centerY), (a = Math.sqrt(o * o + h * h)) < (r = e.radius + t.radius)) { u = !0, n = r - a, n += .3, l = o / a, d = h / a, e.x -= n * l, e.y -= n * d, i && (c.x = h, c.y = -o, bounceOffSurface(e, c)) }
    return u
}

function movingCircleCollision(e, t, i = !1) {
    let s, a, r, n, o = {},
        h = {},
        l = {},
        d = {},
        c = {},
        u = !1;
    if (e.mass = e.mass || 1, t.mass = t.mass || 1, i ? (o.vx = t.gx + t.radius - (e.gx + e.radius), o.vy = t.gy + t.radius - (e.gy + e.radius)) : (o.vx = t.centerX - e.centerX, o.vy = t.centerY - e.centerY), o.magnitude = Math.sqrt(o.vx * o.vx + o.vy * o.vy), s = e.radius + t.radius, o.magnitude < s) {
        u = !0, a = s - o.magnitude, a += .3, o.dx = o.vx / o.magnitude, o.dy = o.vy / o.magnitude, o.vxHalf = Math.abs(o.dx * a / 2), o.vyHalf = Math.abs(o.dy * a / 2), r = e.x > t.x ? 1 : -1, n = e.y > t.y ? 1 : -1, e.x = e.x + o.vxHalf * r, e.y = e.y + o.vyHalf * n, t.x = t.x + o.vxHalf * -r, t.y = t.y + o.vyHalf * -n, o.lx = o.vy, o.ly = -o.vx;
        let i = e.vx * o.dx + e.vy * o.dy;
        h.x = i * o.dx, h.y = i * o.dy;
        let f = e.vx * (o.lx / o.magnitude) + e.vy * (o.ly / o.magnitude);
        l.x = f * (o.lx / o.magnitude), l.y = f * (o.ly / o.magnitude);
        let g = t.vx * o.dx + t.vy * o.dy;
        d.x = g * o.dx, d.y = g * o.dy;
        let p = t.vx * (o.lx / o.magnitude) + t.vy * (o.ly / o.magnitude);
        c.x = p * (o.lx / o.magnitude), c.y = p * (o.ly / o.magnitude), e.bounce = {}, e.bounce.x = l.x + d.x, e.bounce.y = l.y + d.y, t.bounce = {}, t.bounce.x = h.x + c.x, t.bounce.y = h.y + c.y, e.vx = e.bounce.x / e.mass, e.vy = e.bounce.y / e.mass, t.vx = t.bounce.x / t.mass, t.vy = t.bounce.y / t.mass
    }
    return u
}

function multipleCircleCollision(e, t = !1) { for (let s = 0; s < e.length; s++) { var i = e[s]; for (let a = s + 1; a < e.length; a++) { movingCircleCollision(i, e[a], t) } } }

function hitTestRectangle(e, t, i = !1) { let s, a, r, n, o; return s = !1, i ? (n = e.gx + e.halfWidth - (t.gx + t.halfWidth), o = e.gy + e.halfHeight - (t.gy + t.halfHeight)) : (n = e.centerX - t.centerX, o = e.centerY - t.centerY), a = e.halfWidth + t.halfWidth, r = e.halfHeight + t.halfHeight, s = Math.abs(n) < a && Math.abs(o) < r }

function rectangleCollision(e, t, i = !1, s = !0) { let a, r, n, o, h, l, d; return s ? (l = e.gx + e.halfWidth - (t.gx + t.halfWidth), d = e.gy + e.halfHeight - (t.gy + t.halfHeight)) : (l = e.centerX - t.centerX, d = e.centerY - t.centerY), r = e.halfWidth + t.halfWidth, n = e.halfHeight + t.halfHeight, Math.abs(l) < r && Math.abs(d) < n && ((o = r - Math.abs(l)) >= (h = n - Math.abs(d)) ? (d > 0 ? (a = "top", e.y = e.y + h) : (a = "bottom", e.y = e.y - h), i && (e.vy *= -1)) : (l > 0 ? (a = "left", e.x = e.x + o) : (a = "right", e.x = e.x - o), i && (e.vx *= -1))), a }

function hitTestCircleRectangle(e, t, i = !1) {
    let s, a, r, n, o, h;
    if (i ? (r = e.gx, n = e.gy, o = t.gx, h = t.gy) : (r = e.x, n = e.y, o = t.x, h = t.y), "topMiddle" === (s = n < h - t.halfHeight ? r < o - 1 - t.halfWidth ? "topLeft" : r > o + 1 + t.halfWidth ? "topRight" : "topMiddle" : n > h + t.halfHeight ? r < o - 1 - t.halfWidth ? "bottomLeft" : r > o + 1 + t.halfWidth ? "bottomRight" : "bottomMiddle" : r < o - t.halfWidth ? "leftMiddle" : "rightMiddle") || "bottomMiddle" === s || "leftMiddle" === s || "rightMiddle" === s) a = hitTestRectangle(e, t, i);
    else {
        let r = {};
        switch (s) {
            case "topLeft":
                r.x = o, r.y = h;
                break;
            case "topRight":
                r.x = o + t.width, r.y = h;
                break;
            case "bottomLeft":
                r.x = o, r.y = h + t.height;
                break;
            case "bottomRight":
                r.x = o + t.width, r.y = h + t.height
        }
        a = hitTestCirclePoint(e, r, i)
    }
    return a ? s : a
}

function hitTestCirclePoint(e, t, i = !1) { return t.diameter = 1, t.radius = .5, t.centerX = t.x, t.centerY = t.y, t.gx = t.x, t.gy = t.y, hitTestCircle(e, t, i) }

function circleRectangleCollision(e, t, i = !1, s = !1) {
    let a, r, n, o, h, l;
    if (s ? (n = e.gx, o = e.gy, h = t.gx, l = t.gy) : (n = e.x, o = e.y, h = t.x, l = t.y), "topMiddle" === (a = o < l - t.halfHeight ? n < h - 1 - t.halfWidth ? "topLeft" : n > h + 1 + t.halfWidth ? "topRight" : "topMiddle" : o > l + t.halfHeight ? n < h - 1 - t.halfWidth ? "bottomLeft" : n > h + 1 + t.halfWidth ? "bottomRight" : "bottomMiddle" : n < h - t.halfWidth ? "leftMiddle" : "rightMiddle") || "bottomMiddle" === a || "leftMiddle" === a || "rightMiddle" === a) r = rectangleCollision(e, t, i, s);
    else {
        let n = {};
        switch (a) {
            case "topLeft":
                n.x = h, n.y = l;
                break;
            case "topRight":
                n.x = h + t.width, n.y = l;
                break;
            case "bottomLeft":
                n.x = h, n.y = l + t.height;
                break;
            case "bottomRight":
                n.x = h + t.width, n.y = l + t.height
        }
        r = circlePointCollision(e, n, i, s)
    }
    return r ? a : r
}

function circlePointCollision(e, t, i = !1, s = !1) { return t.diameter = 1, t.radius = .5, t.centerX = t.x, t.centerY = t.y, t.gx = t.x, t.gy = t.y, circleCollision(e, t, i, s) }

function bounceOffSurface(e, t) {
    let i, s, a = {},
        r = {},
        n = {},
        o = e.mass || 1;
    t.lx = t.y, t.ly = -t.x, t.magnitude = Math.sqrt(t.x * t.x + t.y * t.y), t.dx = t.x / t.magnitude, t.dy = t.y / t.magnitude, i = e.vx * t.dx + e.vy * t.dy, a.vx = i * t.dx, a.vy = i * t.dy, s = e.vx * (t.lx / t.magnitude) + e.vy * (t.ly / t.magnitude), r.vx = s * (t.lx / t.magnitude), r.vy = s * (t.ly / t.magnitude), r.vx *= -1, r.vy *= -1, n.x = a.vx + r.vx, n.y = a.vy + r.vy, e.vx = n.x / o, e.vy = n.y / o
}(Pebble.contain = function(e, t, i = !1, s = (() => {})) {
    let a, r = t.x,
        n = t.y,
        o = t.width,
        h = t.height;
    return e.x < r && (i && (e.vx *= -1), e.mass && (e.vx /= e.mass), e.x = r, a = "left"), e.y < n && (i && (e.vy *= -1), e.mass && (e.vy /= e.mass), e.y = n, a = "top"), e.x + e.width > o && (i && (e.vx *= -1), e.mass && (e.vx /= e.mass), e.x = o - e.width, a = "right"), e.y + e.height > h && (i && (e.vy *= -1), e.mass && (e.vy /= e.mass), e.y = h - e.height, a = "bottom"), a && s && s(a), a
}, Pebble.hit = function(e, t, i = !1, s = !1, a, r) {
    let n, o = void 0 !== e.parent,
        h = void 0 !== t.parent;
    return o && t instanceof Array || h && e instanceof Array ? function() {
        if (e instanceof Array) { let [e, t] = [t, e] }
        for (let i = t.length - 1; i >= 0; i--) {
            let s = t[i];
            (n = l(e, s)) && r && r(n, s)
        }
    }() : (n = l(e, t)) && r && r(n), n;

    function l(e, t) {
        let r = void 0 !== e.parent,
            n = void 0 !== t.parent;
        if (r && n) return e.diameter && t.diameter ? function(e, t) { return i ? e.vx + e.vy !== 0 && t.vx + t.vy !== 0 ? movingCircleCollision(e, t, a) : circleCollision(e, t, s, a) : hitTestCircle(e, t) }(e, t) : e.diameter && !t.diameter ? function(e, t) { return i ? circleRectangleCollision(e, t, s, a) : hitTestCircleRectangle(e, t, a) }(e, t) : function(e, t) { return i ? rectangleCollision(e, t, s, a) : hitTestRectangle(e, t, a) }(e, t);
        if (n && void 0 !== e.x && void 0 !== e.y) return hitTestPoint(e, t);
        throw new Error(`I'm sorry, ${e} and ${t} cannot be use together in a collision test.'`)
    }
}, Pebble.Storage = class {
    constructor() {
        if (this.databases = [], this.openDatabases = [], window.localStorage.length > 0)
            for (let e = 0; e < window.localStorage.length; e++) {
                let t = window.localStorage.key(e),
                    i = window.localStorage.getItem(t);
                "{id:" == i.slice(0, 4) && "string" == typeof(i = JSON.parse(i)).id && this.databases.push(i)
            }
    }
    createDB(e = "") { let t = !0; if (this.databases.length > 0 && this.databases.forEach(i => { i.id === e && (t = !1) }), !0 === t) { let t = { id: e, db: { storage: [] } }; return this.databases.push(t), window.localStorage.setItem(e, JSON.stringify(t)), !0 } return !1 }
    removeDB(e = "") { let t = this.databases.find(t => t.id === e); if (t.id) { let e = this.databases.indexOf(t); return window.localStorage.removeItem(t.id), this.databases.splice(e, 1), !0 } return !1 }
    open(e = "", t) {
        try {
            let i = JSON.parse(window.localStorage.getItem(e));
            this.openDatabases.push(i);
            let s = this.openDatabases.indexOf(i);
            return Object.assign(this.openDatabases[s].db, {
                createNode(e = "", t) { this.storage.length > 0 && this.storage.forEach(t => { if (e === t.name) throw new Error("This name has already been taken") }); let i = { name: e, value: t, type: typeof t }; return this.storage.push(i), !0 },
                removeNode(e) {
                    let t = this.storage.find(t => t.name === e),
                        i = this.storage.indexOf(t);
                    return this.storage.splice(i, 1), !0
                },
                updateNode(e = "", t) {
                    if (this.storage.length > 0) try {
                        this.storage.forEach(i => {
                            if (i.name === e && i.type === typeof t) i.value = t;
                            else if (void 0 === i.name) throw new Error
                        })
                    } catch (t) { throw new Error(`Node ${e} either doesn't exist, or the value you tried to update is not of the same type`) }
                },
                getNode(e = "") {
                    console.log(this.storage);
                    for (let t of this.storage)
                        if (t.name === e) return t.value;
                    return !1
                },
                removeAll() {},
                getAll() {}
            }), t && t(this.openDatabases[s].db), !0
        } catch (e) { return this.openDatabases.pop(), !1 }
    }
    checkDB(e = "") { return !!this.open(e) && (this.close(e), !0) }
    close(e = "") {
        let t = this.openDatabases.find(t => t.id === e);
        window.localStorage.setItem(t.id, JSON.stringify(t));
        let i = this.openDatabases.indexOf(t);
        if (this.openDatabases.splice(i, 1), this.databases = [], window.localStorage.length > 0)
            for (let e = 0; e < window.localStorage.length; e++) {
                let t = window.localStorage.key(e),
                    i = window.localStorage.getItem(t);
                "string" == typeof(i = JSON.parse(i)).id && this.databases.push(i)
            }
        return !0
    }
    removeAll() { return this.databases.forEach(e => this.removeDB(e.id)), !0 }
    closeAll() { return this.openDatabases.forEach(e => this.close(e.id)), !0 }
}, null == Pebble) && (Pebble = class {
    static info() { return "visit www.slidemations.com for info on the Pebble API" }
    static randomInt(e = 0, t = 10) { return Math.floor(Math.random() * (t - e) + e) }
    static randomFloat(e = 0, t = 0, i) { return void 0 === i && (i = 2), parseFloat(Math.min(e + Math.random() * (t - e), t).toFixed(i)) }
});
(Pebble.Keyboard = function(e = 0, t = window) { let i = {}; return i.eObj = t, i.code = e, i.isDown = !1, i.isUp = !0, i.press = void 0, i.release = void 0, i.downHandler = function(e) { e.keyCode === i.code && (i.isUp && i.press && i.press(), i.isDown = !0, i.isUp = !1), e.preventDefault() }, i.upHandler = function(e) { e.keyCode === i.code && (i.isDown && i.release && i.release(), i.isDown = !1, i.isUp = !0), e.preventDefault() }, i.eObj.addEventListener("keydown", i.downHandler.bind(i), !1), i.eObj.addEventListener("keyup", i.upHandler.bind(i), !1), i }, Pebble.Pointer = function(e = document.body, t = 1) {
    let i = {
        element: e,
        scale: t,
        _x: 0,
        _y: 0,
        get x() { return this._x / this.scale + this.element.scrollLeft },
        get y() { return this._y / this.scale + this.element.scrollTop },
        get centerX() { return this.x },
        get centerY() { return this.y },
        get position() { return { x: this.x, y: this.y } },
        isDown: !1,
        isUp: !0,
        tapped: !1,
        downTime: 0,
        elapsedTime: 0,
        press: void 0,
        release: void 0,
        tap: void 0,
        dragSprite: null,
        dragOffsetX: 0,
        dragOffsetY: 0,
        moveHandler(e) {
            let t = e.target;
            this._x = e.pageX - t.offsetLeft, this._y = e.pageY - t.offsetTop, e.preventDefault()
        },
        touchmoveHandler(e) {
            let t = e.target;
            this._x = e.targetTouches[0].pageX - t.offsetLeft, this._y = e.targetTouches[0].pageY - t.offsetTop, e.preventDefault()
        },
        downHandler(e) { this.isDown = !0, this.isUp = !1, this.tapped = !1, this.downTime = Date.now(), this.press && this.press(), e.preventDefault() },
        touchstartHandler(e) {
            let t = e.target;
            this._x = e.targetTouches[0].pageX - t.offsetLeft, this._y = e.targetTouches[0].pageY - t.offsetTop, this.isDown = !0, this.isUp = !1, this.tapped = !1, this.downTime = Date.now(), this.press && this.press(), e.preventDefault()
        },
        upHandler(e) { this.elapsedTime = Math.abs(this.downTime - Date.now()), this.elapsedTime <= 200 && !1 === this.tapped && (this.tapped = !0, this.tap && this.tap()), this.isUp = !0, this.isDown = !1, this.release && this.release(), e.preventDefault() },
        touchendHandler(e) { this.elapsedTime = Math.abs(this.downTime - Date.now()), this.elapsedTime <= 200 && !1 === this.tapped && (this.tapped = !0, this.tap && this.tap()), this.isUp = !0, this.isDown = !1, this.release && this.release(), e.preventDefault() },
        hitTestSprite(e) {
            let t = !1;
            if (e.circular) {
                let i = this.x - (e.gx + e.radius),
                    s = this.y - (e.gy + e.radius);
                t = Math.sqrt(i * i + s * s) < e.radius
            } else {
                let i = e.gx,
                    s = e.gx + e.width,
                    a = e.gy,
                    r = e.gy + e.height;
                t = this.x > i && this.x < s && this.y > a && this.y < r
            }
            return t
        },
        updateDragAndDrop(e) {
            if (this.isDown)
                if (null === this.dragSprite)
                    for (let t = e.length - 1; t > -1; t--) {
                        let i = e[t];
                        if (this.hitTestSprite(i) && i.draggable) {
                            this.dragOffsetX = this.x - i.gx, this.dragOffsetY = this.y - i.gy, this.dragSprite = i;
                            let t = i.parent.children;
                            t.splice(t.indexOf(i), 1), t.push(i), e.splice(e.indexOf(i), 1), e.push(i);
                            break
                        }
                    } else this.dragSprite.x = this.x - this.dragOffsetX, this.dragSprite.y = this.y - this.dragOffsetY;
            this.isUp && (this.dragSprite = null), e.some(e => this.hitTestSprite(e) && e.draggable ? (this.element.style.cursor = "pointer", !0) : (this.element.style.cursor = "auto", !1))
        }
    };
    return e.addEventListener("mousemove", i.moveHandler.bind(i), !1), e.addEventListener("mousedown", i.downHandler.bind(i), !1), window.addEventListener("mouseup", i.upHandler.bind(i), !1), e.addEventListener("touchmove", i.touchmoveHandler.bind(i), !1), e.addEventListener("touchstart", i.touchstartHandler.bind(i), !1), window.addEventListener("touchend", i.touchendHandler.bind(i), !1), e.style.touchAction = "none", i
}, Pebble.sleep = function(e = 0) {
    let t = new Date,
        i = null;
    do { i = new Date } while (i - t < e)
}, Pebble.distance = function(e, t) {
    let i = t.centerX - e.centerX,
        s = t.centerY - e.centerY;
    return Math.sqrt(i * i + s + s)
}, Pebble.followEase = function(e, t, i = .1) {
    let s = t.centerX - e.centerX,
        a = t.centerY - e.centerY;
    Math.sqrt(s * s + a * a) >= 1 && (e.x += s * i, e.y += a * i)
}, Pebble.followConstant = function(e, t, i = .1) {
    let s = t.centerX - e.centerX,
        a = t.centerY - e.centerY,
        r = Math.sqrt(s * s + a * a);
    r >= 1 * i && (e.x += s / r * i, e.y += a / r * i)
}, Pebble.angle = function(e, t) { return Math.atan2(t.centerY - e.centerY, t.centerX - e.centerX) }, Pebble.rotateSprite = function(e, t, i, s) { void 0 === e.angle && (e.angle = 0), e.angle += s, e.x = t.centerX - e.parent.x + i * Math.cos(e.angle) - e.halfWidth, e.y = t.centerY - e.parent.y + i * Math.sin(e.angle) - e.halfWidth }, null == Pebble) && (Pebble = class {
    static info() { return "visit www.slidemations.com for info on the Pebble API" }
    static randomInt(e = 0, t = 10) { return Math.floor(Math.random() * (t - e) + e) }
    static randomFloat(e = 0, t = 0, i) { return void 0 === i && (i = 2), parseFloat(Math.min(e + Math.random() * (t - e), t).toFixed(i)) }
});
(Pebble.Webcam = function(e = document.body, t = 100, i = 100, s = "margin: 0px auto;border: 1px dashed black;width: 200px;height: 200px;background: # 666;") {
    let a = document.createElement("video");
    a.setAttribute("style", s), a.autoplay = !0, a.width = t, a.height = i, navigator.mediaDevices.getUserMedia && navigator.mediaDevices.getUserMedia({ video: !0 }).then(e => a.srcObject = e).catch(e => console.log(e));
    let r = {
        domElement: a,
        stop: function() {
            let e = this.domElement.srcObject.getTracks();
            for (var t = 0; t < e.length; t++) { e[t].stop() }
            this.domElement.srcObject = null
        },
        start: function() { navigator.mediaDevices.getUserMedia && navigator.mediaDevices.getUserMedia({ video: !0 }).then(e => this.domElement.srcObject = e).catch(e => console.log(e)) },
        captureFrame: function(e = "", t = "image/png") { if (void 0 === Pebble.DisplayObject || void 0 === Pebble.DisplayObject) throw new Error("Pebble2d is required for this action"); { let i = new Pebble.Canvas(document.body, this.domElement.width, this.domElement.height, "none", "rgba(0,0,0,0)"); if (i.domElement.style.display = "none", i.domElement.style.position = "absolute", i.ctx.drawImage(this.domElement, 0, 0, this.domElement.width, this.domElement.height), e) return "image/png" === t && i.exportAsPNG(e), "image/jpeg" === t ? i.exportAsJPG(e) : i.exportAsPNG(e), void document.body.removeChild(i.domElement); { let e = i.domElement.toDataURL(t); return document.body.removeChild(i.domElement), e } } }
    };
    return e.appendChild(r.domElement), r
}, null == Pebble) && (Pebble = class {
    static info() { return "visit www.slidemations.com for info on the Pebble API" }
    static randomInt(e = 0, t = 10) { return Math.floor(Math.random() * (t - e) + e) }
    static randomFloat(e = 0, t = 0, i) { return void 0 === i && (i = 2), parseFloat(Math.min(e + Math.random() * (t - e), t).toFixed(i)) }
});
Pebble.Matrix = class {
    constructor(e, t) { this.rows = e, this.cols = t, this.data = Array(this.rows).fill().map(() => Array(this.cols).fill(0)) }
    copy() {
        let e = new Pebble.Matrix(this.rows, this.cols);
        for (let t = 0; t < this.rows; t++)
            for (let i = 0; i < this.cols; i++) e.data[t][i] = this.data[t][i];
        return e
    }
    static fromArray(e) { return new Pebble.Matrix(e.length, 1).map((t, i) => e[i]) }
    static subtract(e, t) {
        if (e.rows === t.rows && e.cols === t.cols) return new Pebble.Matrix(e.rows, e.cols).map((i, s, a) => e.data[s][a] - t.data[s][a]);
        console.log("Columns and Rows of A must match Columns and Rows of B.")
    }
    toArray() {
        let e = [];
        for (let t = 0; t < this.rows; t++)
            for (let i = 0; i < this.cols; i++) e.push(this.data[t][i]);
        return e
    }
    randomize() { return this.map(e => 2 * Math.random() - 1) }
    add(e) { return e instanceof Pebble.Matrix ? this.rows !== e.rows || this.cols !== e.cols ? void console.log("Columns and Rows of A must match Columns and Rows of B.") : this.map((t, i, s) => t + e.data[i][s]) : this.map(t => t + e) }
    static transpose(e) { return new Pebble.Matrix(e.cols, e.rows).map((t, i, s) => e.data[s][i]) }
    static multiply(e, t) {
        if (e.cols === t.rows) return new Pebble.Matrix(e.rows, t.cols).map((i, s, a) => { let r = 0; for (let i = 0; i < e.cols; i++) r += e.data[s][i] * t.data[i][a]; return r });
        console.log("Columns of A must match rows of B.")
    }
    multiply(e) { return e instanceof Pebble.Matrix ? this.rows !== e.rows || this.cols !== e.cols ? void console.log("Columns and Rows of A must match Columns and Rows of B.") : this.map((t, i, s) => t * e.data[i][s]) : this.map(t => t * e) }
    map(e) {
        for (let t = 0; t < this.rows; t++)
            for (let i = 0; i < this.cols; i++) {
                let s = this.data[t][i];
                this.data[t][i] = e(s, t, i)
            }
        return this
    }
    static map(e, t) { return new Pebble.Matrix(e.rows, e.cols).map((i, s, a) => t(e.data[s][a], s, a)) }
    print() { return console.table(this.data), this }
    serialize() { return JSON.stringify(this) }
    static deserialize(e) { "string" == typeof e && (e = JSON.parse(e)); let t = new Pebble.Matrix(e.rows, e.cols); return t.data = e.data, t }
}, Pebble.ActivationFunction = class { constructor(e, t) { this.func = e, this.dfunc = t } };
let sigmoid = new Pebble.ActivationFunction(e => 1 / (1 + Math.exp(-e)), e => e * (1 - e)),
    tanh = new Pebble.ActivationFunction(e => Math.tanh(e), e => 1 - e * e);
if (Pebble.NeuralNetwork = class {
        constructor(e, t, i) {
            if (e instanceof Pebble.NeuralNetwork) {
                let t = e;
                this.input_nodes = t.input_nodes, this.hidden_nodes = t.hidden_nodes, this.output_nodes = t.output_nodes, this.weights_ih = t.weights_ih.copy(), this.weights_ho = t.weights_ho.copy(), this.bias_h = t.bias_h.copy(), this.bias_o = t.bias_o.copy()
            } else this.input_nodes = e, this.hidden_nodes = t, this.output_nodes = i, this.weights_ih = new Pebble.Matrix(this.hidden_nodes, this.input_nodes), this.weights_ho = new Pebble.Matrix(this.output_nodes, this.hidden_nodes), this.weights_ih.randomize(), this.weights_ho.randomize(), this.bias_h = new Pebble.Matrix(this.hidden_nodes, 1), this.bias_o = new Pebble.Matrix(this.output_nodes, 1), this.bias_h.randomize(), this.bias_o.randomize();
            this.setLearningRate(), this.setActivationFunction()
        }
        predict(e) {
            let t = Pebble.Matrix.fromArray(e),
                i = Pebble.Matrix.multiply(this.weights_ih, t);
            i.add(this.bias_h), i.map(this.activation_function.func);
            let s = Pebble.Matrix.multiply(this.weights_ho, i);
            return s.add(this.bias_o), s.map(this.activation_function.func), s.toArray()
        }
        setLearningRate(e = .1) { this.learning_rate = e }
        setActivationFunction(e = sigmoid) { this.activation_function = e }
        train(e, t) {
            let i = Pebble.Matrix.fromArray(e),
                s = Pebble.Matrix.multiply(this.weights_ih, i);
            s.add(this.bias_h), s.map(this.activation_function.func);
            let a = Pebble.Matrix.multiply(this.weights_ho, s);
            a.add(this.bias_o), a.map(this.activation_function.func);
            let r = Pebble.Matrix.fromArray(t),
                n = Pebble.Matrix.subtract(r, a),
                o = Pebble.Matrix.map(a, this.activation_function.dfunc);
            o.multiply(n), o.multiply(this.learning_rate);
            let h = Pebble.Matrix.transpose(s),
                l = Pebble.Matrix.multiply(o, h);
            this.weights_ho.add(l), this.bias_o.add(o);
            let d = Pebble.Matrix.transpose(this.weights_ho),
                c = Pebble.Matrix.multiply(d, n),
                u = Pebble.Matrix.map(s, this.activation_function.dfunc);
            u.multiply(c), u.multiply(this.learning_rate);
            let f = Pebble.Matrix.transpose(i),
                g = Pebble.Matrix.multiply(u, f);
            this.weights_ih.add(g), this.bias_h.add(u)
        }
        serialize() { return JSON.stringify(this) }
        static deserialize(e) { "string" == typeof e && (e = JSON.parse(e)); let t = new NeuralNetwork(e.input_nodes, e.hidden_nodes, e.output_nodes); return t.weights_ih = Matrix.deserialize(e.weights_ih), t.weights_ho = Matrix.deserialize(e.weights_ho), t.bias_h = Matrix.deserialize(e.bias_h), t.bias_o = Matrix.deserialize(e.bias_o), t.learning_rate = e.learning_rate, t }
        copy() { return new NeuralNetwork(this) }
        mutate(e) { this.weights_ih.map(e), this.weights_ho.map(e), this.bias_h.map(e), this.bias_o.map(e) }
    }, void 0 === Pebble.DisplayObject || null === Pebble.DisplayObject) throw new Error("You must execute Pebble-2d.js before you can use this");
Pebble.World = class {
    constructor(e) {
        this.scenes = [], this.currentScene = 0, this.stage = e;
        this.cGroup = class extends Pebble.DisplayObject {
            constructor(e, t) { super(), this.width = e, this.height = t }
            addChild(e) { e.parent && e.parent.removeChild(e), e.parent = this, this.children.push(e) }
            removeChild(e) {
                if (e.parent !== this) throw new Error(`${e} is not a child of ${this}`);
                this.children.splice(this.children.indexOf(e), 1)
            }
            add(...e) { e.forEach(e => { this.addChild(e) }) }
            remove(...e) { e.forEach(e => { this.removeChild(e) }) }
            addArray(e) { e.forEach(e => { this.addChild(e) }) }
            removeArray(...e) { e.forEach(e => { this.removeChild(e) }) }
        }
    }
    addNewScene(e = function(e, t, i) {}, t = function(e, t, i) {}) {
        let i = { group: new this.cGroup(this.stage.width, this.stage.height), prepare: () => e(this, i.objects, i.group), update: () => t(this, i.objects, i.group), objects: {} };
        i.group.parent || this.stage.add(i.group), this.scenes.push(i), i.group.visible = 0 === this.scenes.indexOf(i), i.group.visible && i.prepare()
    }
    nextScene() {
        if (this.currentScene < this.scenes.length - 1) {
            this.scenes[this.currentScene].group.visible = !1, this.currentScene++;
            this.scenes[this.currentScene].group.visible = !0;
            this.scenes[this.currentScene].prepare()
        } else this.scenes[this.currentScene].group.visible = !1, this.currentScene = 0, this.scenes[this.currentScene].prepare(), this.scenes[this.currentScene].group.visible = !0
    }
    gotoScene(e) { Number.isInteger(e) && e >= 0 && e < this.scenes.length && (this.Scene.group.visible = !1, this.currentScene = e, this.scenes[this.currentScene].prepare(), this.scenes[this.currentScene].group.visible = !0) }
    get Scene() { return this.scenes[this.currentScene] }
}, Pebble.shoot = function(e, t, i, s, a, r) {
    let n = r();
    n.x = e.centerX - n.halfWidth + i * Math.cos(t), n.y = e.centerY - n.halfHeight + i * Math.sin(t), n.vx = Math.cos(t) * s, n.vy = Math.sin(t) * s, a.push(n)
};